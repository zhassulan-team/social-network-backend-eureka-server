Описание проекта social-network
=====================================

1) На проекте используется DOCKER, для запуска баз данных в докере используется команда docker-compose up -d в корневой
   папке проекта eureka.

2) На проекте используется LOMBOK.

3) Аннотации lombok которые мы используем @RequiredArgsConstructor @AllArgsConstructor @NoArgsConstructor @Getter
   @Setter @Builder. Equals и hashcode нужно переопределять самим через IDEA Alt + Insert (java 7+).

4) Если нужно заинжектить какие то классы в контроллер, сервис и тд... используйте не сам класс, а интерфейс который он
   реализует. Например: UserService, а не UserServiceImpl.

5) Инжектирование или внедрение бинов нужно делать через конструктор, если есть такая возможность. Преимущественно через
   аннотацию @RequiredArgsConstructor.

6) В контроллерах используются аннотации @Validated, @Valid для валидации принимаемых данных.

7) Исключения, выбрасываемые контроллерами и сервисами, обрабатываются не в самих контроллерах и сервисах, а снаружи -
   методами класса AdviceRestController.

8) В качестве ответа клиенту (внешние контроллеры) из всех REST контроллеров используется класс ResponseEntity<>
   обязательно параметризованный. Если ничего не нужно отправлять, то параметризовывать Void, те ResponseEntity\<Void>.
   Если нужно вернуть данные, то необходимо обернуть в Data, те ResponseEntity<Data\<Integer>>.

9) В качестве ответа другим микросервисам (внутренние контроллеры) из всех REST контроллеров используется класс
   ResponseEntity<> обязательно параметризованный. Если ничего не нужно отправлять, то параметризовывать Void, те
   ResponseEntity\<Void>. Если нужно вернуть данные, то необходимо обернуть в Data, те ResponseEntity<
   Data\<Integer>>.

10) На проекте используется микросервисная архитектура. Каждый сервис должен выполнять только свою часть работы и по
    необходимости для реализации своей логики обращаться в другие микросервисы.

11) Для реализации мискросервисной архитектуры используется решение от компании Netflix Eureka-Server, Eureka-Client.

12) Главным сервисом является eureka-server. В нем регистрируются все остальные микросервисы, те им нужно знать где он
    находится. Uri eureka-server явно прописывается в каждом сервисе. Для указания что этот сервис будет регистрировать
    другие сервисы, необходимо поставить аннотацию @EnableEurekaServer.

13) Остальные микросервисы должны зарегестрироваться в Eureka-server, для этого необходимо указать uri eureka-server и
    поставить аннотацию @EnableEurekaClient.

14) Для маршрутизации запросов от клиента мы используем сервис eureka-api-gateway. Для настройки маршрутизации в этом
    сервисе используется зависимость spring-cloud-starter-gateway.

15) Eureka-api-gateway получает все запросы от клиента, пропускает через свою цепочку фильтров (секьюрность) и
    перенаправляет запрос в нужный микросервис.

16) Каждый микросервис должен иметь свою базу данных, если новому сервису необходимо добавить базу, то необходимо
    добавить создание базы в докере в eureka репозитории в файле docker-compose.yml.

17) Для обращения в другой микросервис используется FeignClient, ему не нужно знать хост и порт на котором запущен
    сервис,
    достаточно указать название сервиса, а Eureka-server сам предоставит путь до необходимого микросервиса.

18) В случае если микросервис недоступен или произошло исключение, то такой кейс обрабатывается в FeignClientFallback.


19) Code Style

* Убрать импорт \*, должны импоритроваться только нужные пакеты Settings -> Editor -> Code Style -> Java -> Imports ->
  Class count to use import with '\*' = 999, Names count to use static import with '\*' = 999.
* Отступы должны быть 4 пробела, не использовать табуляцию Settings -> Editor -> Code Style -> Java -> Tabs and
  Indents -> Use tab character должен быть отключен, Tab size = 4, Ident = 4, Label indent = 0.
* Все ветки ДОЛЖНЫ ответвляться от ветки dev предварительно обновив ее, чтоб было меньше конфилктов. И создавать
  PullRequest соответственно в ветку dev.
* НЕЛЬЗЯ делать коммиты и пушить напрямую в ветку dev или любую другую не вашу ветку.
* НЕЛЬЗЯ самим мержить PullRequest, этим занимается только REVIEWER после проверки вашего кода.
* Название ветки должно начинаться с ключевого слова BACK номера задачи, затем дефис feature и потом описание через
  дефис. Например: BACK15-feature-add-tests-UserRestController или BACK20-feature-fix-bug-with-account-registration.
* Сообщение коммита должно быть от имени коммита и должно начинаться с номера задачи. Можно мысленно добавить фразу '
  Коммит ...' и дальше описывать что он выполняет. Например: 'BACK20 Удаляет метод в UserService::getAll' или 'BACK5
  Фиксит регастрацию студента в UserService'.

20) Интеграционные тесты

* Каждый тестовый класс должен полностью повторять название тестового класса с приставкой IT в конце и наследоваться от
  SpringSimpleContextTest. Например: public class UserRegistrationRestControllerIT extends SpringSimpleContextTest{}.
* Каждый метод в тестовом классе должен должен повторять название метода в контроллере, затем _ и с большой буквы
  описывать тест, конец метода должен заканчиваться Test. Например: registerNewUser_SuccessfulTest,
  registerNewUser_WithExistingUsernameTest.
* В тестах не должна использоваться аннотация @Transactional.
* Если тест добавляет, обновляет или удаляет данные, то обязательно должен быть запрос в бд через EntityManager для
  подтверждения, что данные действительно изменились.
* База данных для тестов поднимается автоматически в докер контейнере.
* На каждый контроллер создается свой пакет с тестовыми данными. Пакет должен лежать в scripts/ и дальше структура папок
  начиная от rest. Например: kata.academy.content.rest.inner.UserRegistrationRestController значит
  scripts/inner/UserRegistrationRestController.
* Каждый тест должен иметь собственный пакет с тестовыми данными и лежать в пакете соответствующего контроллера.
  Название пакета должно должно совпадать с названием теста. В пакете должно быть 2 .sql файла: BeforeTest.sql и
  AfterTest.sql. Например: scripts/inner/UserRegistrationRestController/registerNewUser_SuccessfulTest/BeforeTest.sql.
  Очищение тестовых данных после теста должно использовать TRUNCATE TABLE название таблицы CASCADE.
* Каждый тест должен инициализировать тестовые данные необходимые только для теста и по окончанию очищать все после
  себя, не загружать тестовые данные для всего тестового класса.

21) Полезные ссылки

* Микросервисная архитектура https://www.youtube.com/watch?v=_2W43xoyWOw&list=PL8X2nqRlWfaZcyrJrsrWmQ17vtagWKv3f
*

FeignClient https://medium.com/@kirill.sereda/spring-cloud-netflix-feign-%D0%BF%D0%BE-%D1%80%D1%83%D1%81%D1%81%D0%BA%D0%B8-7b8272e8e110

* О тестах в принципе https://habr.com/ru/post/358950/
* Тест контейнеры https://habr.com/ru/post/681232/
* Junit5 https://habr.com/ru/post/590607/
* Мокито https://habr.com/ru/post/444982/